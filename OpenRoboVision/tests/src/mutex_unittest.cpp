//
// OpenRoboVision
//
// test mutex object
//
// тестирование объекта мьютекса
//
//
// robocraft.ru
//

//
// http://easy-coding.blogspot.com/2009/02/c-windows-unix.html
//

#include "gtest/gtest.h"

#include "orv/system/thread.h"
#include "orv/system/mutex.h"
#include "orv/system/times.h"

//
// тестирование мьютекса
//

// Определим параллельный поток, который будет
// "конкурировать" с основным потоком за блокировку.
// Данный поток будет пытаться захватить блокировку,
// изменить значение флага и освободить затем
// блокировку.
class A: public BaseThread 
{
public:
	// Передаем в конструкторе ссылку на флаг и 
	// ссылку на блокировку.
	A(volatile int& flag, Mutex& mutex) :
	  __flag(flag), __mutex(mutex)
	  {}

	  void Execute() {
		  // Захват блокировки (1)
		  __mutex.Lock();
		  // Изменяет флаг на 1
		  __flag = 1;
		  // Освобождаем блокировку
		  __mutex.Unlock();
	  }

private:
	volatile int& __flag;
	Mutex& __mutex;
};

TEST(Mutex, Generic)
{
	// Начальное значение флага - 0.
	volatile int flag = 0;

	// Создаем объект-блокировку
	Mutex mutex;
	// Захватываем блокировку.
	mutex.Lock();

	// Создаем параллельный поток выполнения.
	A a(flag, mutex);
	// Запускаем его.
	a.Start();
	// Ждем для проформы десятую секунды, чтобы дать
	// время параллельному потоку создаться и успеть
	// дойти до строки (1), то есть до захвата блокировки.
	orv::time::sleep(100);

	// Значение флага должно быть все еще 0, так как
	// параллельный поток должен быть блокирован на
	// строке (1), так как мы захватили блокировку еще
	// до его создания.
	EXPECT_EQ(0, flag);

	// Освобождаем блокировку, тем самым давая 
	// параллельному потоку выполняться дальше и
	// изменить значение флага на 1.
	mutex.Unlock();

	// Ждем завершения параллельного потока.
	a.Join();
	// Так как параллельный поток завершился, то
	// флаг теперь точно должен быть равен 1.
	EXPECT_EQ(1, flag);
}

//
// тестирование автоматического захвата мьютекса
//

// Тестовый поток
class T: public BaseThread
{
public:
	// Параметры потока:
	//   flag    - флаг для сигнализации о выполненном действии
	//   mutex   - рабочий объект-блокировка
	//   timeout - время, которое необходимо подождать после 
	//             установки флага
	//   val     - значение, в которое надо установить флаг
	T(volatile int& flag, Mutex& mutex, int timeout, int val) :
	  __flag(flag), __mutex(mutex), __timeout(timeout), __val(val)
	  {}

	  // Функция потока: занять автоматическую блокировку, установить
	  // флаг, подождать указанное время, освободить автоматическую
	  // блокировку.
	  void Execute() {
		  MutexAutoLock locker(__mutex);
		  __flag = __val;
		  orv::time::sleep(__timeout);
	  }
private:
	volatile int& __flag;
	Mutex& __mutex;
	int __timeout;
	int __val;
};

// Данный тест выполняет параллельно две функции, которые конкурируют
// за одну блокировку. Функция-поток 'a' занимает блокировку, устанавливает
// флаг в 1, ждет 100мс и затем освобождает блокировку. Функция-поток 'b'
// стартует, когда поток 'a' уже занял блокировку, поэтому после старта
// потока 'b' флаг еще некоторое время будет равен 1, пока поток 'a' не
// отпустит блокировку, и затем поток 'b' изменит флаг в 0, получив 
// управление ожидания на блокировке.
TEST(MutexAutoLock, Generic)
{
	volatile int flag = 0;

	Mutex mutex;

	T a(flag, mutex, 100, 1);
	T b(flag, mutex, 0, 0);

	// Запускаем поток 'a'.
	a.Start();
	// Ждем, пока поток 'a' займет блокировку.
	// Это случится, когда флаг станет равен 1.  
	while (!flag);

	// Запускаем поток 'b'.
	b.Start();
	// Ждем немного, чтобы убедиться, что поток запустился
	// и дошел до попытки занять блокировку.
	orv::time::sleep(50);

	// Так как время задержки в потоке 'a' больше 50мс,
	// то флаг все еще равен 1, так как поток 'a' пока не отпустил
	// блокировку, не давая потоку 'b' получить управление
	// и изменить флаг в 0.
	EXPECT_EQ(1, flag);

	// Ждем завершения потока 'a' (блокировка должна быть
	// отпущена при его завершении.
	a.Join();

	// Ждем завершения потока 'b', который к своему завершению
	// должен обнулить флаг.
	b.Join();
	EXPECT_EQ(0, flag);
}
